"""Interfaces with GROMACS."""
import math
import warnings
from collections import defaultdict
from pathlib import Path
from typing import IO, TYPE_CHECKING, Dict, List, Optional, Set, Tuple, Union

import numpy as np
from openff.toolkit.topology import Molecule, Topology
from openff.units import unit

from openff.interchange.components.toolkit import _get_14_pairs
from openff.interchange.constants import _PME, kj_mol
from openff.interchange.exceptions import MissingPositionsError, UnsupportedExportError
from openff.interchange.interop._virtual_sites import (
    _get_virtual_site_positions,
    _virtual_site_parent_molecule_mapping,
)
from openff.interchange.models import BondKey, PotentialKey, TopologyKey, VirtualSiteKey

if TYPE_CHECKING:
    from numpy.typing import ArrayLike

    from openff.interchange import Interchange
    from openff.interchange.components.potentials import Collection


def to_gro(interchange: "Interchange", file_path: Union[Path, str], decimal: int = 3):
    """
    Write a GROMACS coordinate (.gro) file.

    See https://manual.gromacs.org/documentation/current/reference-manual/file-formats.html#gro
    for more details, including the recommended C-style one-liners

    This code is partially copied from InterMol, see
    https://github.com/shirtsgroup/InterMol/tree/v0.1/intermol/gromacs

    """
    if isinstance(file_path, str):
        path = Path(file_path)
    if isinstance(file_path, Path):
        path = file_path

    if interchange.positions is None:
        raise MissingPositionsError(
            "Positions are required to write a `.gro` file but found None.",
        )
    elif np.allclose(interchange.positions, 0):
        warnings.warn(
            "Positions seem to all be zero. Result coordinate file may be non-physical.",
            UserWarning,
        )
    # Explicitly round here to avoid ambiguous things in string formatting
    rounded_positions = np.round(interchange.positions, decimal)
    rounded_positions = rounded_positions.m_as(unit.nanometer)

    n = decimal

    n_particles = interchange.positions.shape[0]

    if interchange.topology.n_atoms != n_particles:
        raise MissingPositionsError(
            "Found a mismatch in the number of atoms in the provided topology and positions "
            f"matrix. Detected {interchange.topology.n_atoms} atoms in the topology but found "
            f"{n_particles} positions in `.positions` attribute.",
        )

    virtual_site_map = _build_virtual_site_map(interchange)
    n_particles += len(virtual_site_map)

    # this must be Dict[int, List[VirtualSiteKey]] because one molecule can contain multiple virtual sites
    molecule_virtual_site_map = defaultdict(list)

    if len(virtual_site_map) > 0:
        virtual_site_molecule_map = _virtual_site_parent_molecule_mapping(interchange)

        for virtual_site, molecule_index in virtual_site_molecule_map.items():
            molecule_virtual_site_map[molecule_index].append(virtual_site)

    with open(path, "w") as gro:
        gro.write("Generated by Interchange\n")
        gro.write(f"{n_particles}\n")

        n_virtual_sites = 0

        for molecule_index, molecule in enumerate(interchange.topology.molecules):
            for atom in molecule.atoms:
                residue_index, residue_name = _get_residue_info_from_atom(atom)

                topology_index = interchange.topology.atom_index(atom)

                atom_name = atom.name if atom.name else atom.symbol

                gmx_atom_index = (topology_index + 1 + n_virtual_sites) % 100000

                gro.write(
                    f"%5d%-5s%5s%5d%{n+5}.{n}f%{n+5}.{n}f%{n+5}.{n}f\n"
                    % (
                        residue_index,
                        residue_name,
                        atom_name,
                        gmx_atom_index,
                        rounded_positions[topology_index, 0],
                        rounded_positions[topology_index, 1],
                        rounded_positions[topology_index, 2],
                    ),
                )

            try:
                virtual_site_keys: List[VirtualSiteKey] = molecule_virtual_site_map[
                    molecule_index
                ]
            except KeyError:
                # This molecule is not in the mapping between molecules and virtual site keys
                continue

            # Infer residue information from the the last atom we happened to be iterating through in this molecule
            # This will need to be updated to actually point to the right atom, since here we assume the molecule
            # containing virtual sites includes only one residue
            residue_index, residue_name = _get_residue_info_from_atom(atom)

            # TODO: What should virtual sites be named? Does it matter?
            atom_name = "VS"

            last_atom_index = topology_index

            for virtual_site_key in virtual_site_keys:
                r_virtual_site = _get_virtual_site_positions(
                    virtual_site_key,
                    interchange,
                )
                r_virtual_site_nm = r_virtual_site.m_as(unit.nanometer)

                gmx_atom_index = (last_atom_index + 1 + n_virtual_sites) % 100000

                gro.write(
                    f"%5d%-5s%5s%5d%{n+5}.{n}f%{n+5}.{n}f%{n+5}.{n}f\n"
                    % (
                        residue_index,
                        residue_name,
                        atom_name,
                        gmx_atom_index,
                        r_virtual_site_nm[0],
                        r_virtual_site_nm[1],
                        r_virtual_site_nm[2],
                    ),
                )

                n_virtual_sites += 1

        if interchange.box is None:
            warnings.warn(
                "WARNING: System defined with no box vectors, which GROMACS does not offically "
                "support in versions 2020 or newer (see "
                "https://gitlab.com/gromacs/gromacs/-/issues/3526). Setting box vectors to a 5 "
                " nm cube.",
            )
            box = 5 * np.eye(3)
        else:
            box = interchange.box.m_as(unit.nanometer)

        # Check for rectangular
        if (box == np.diag(np.diagonal(box))).all():
            for i in range(3):
                gro.write(f"{box[i, i]:11.7f}")
        else:
            for i in range(3):
                gro.write(f"{box[i, i]:11.7f}")
            for i in range(3):
                for j in range(3):
                    if i != j:
                        gro.write(f"{box[i, j]:11.7f}")

        gro.write("\n")


def to_top(interchange: "Interchange", file_path: Union[Path, str]):
    """
    Write a GROMACS topology (.top) file.

    See https://manual.gromacs.org/documentation/current/reference-manual/file-formats.html#top
    for more details.

    This code is partially copied from InterMol, see
    https://github.com/shirtsgroup/InterMol/tree/v0.1/intermol/gromacs

    """
    if "VirtualSites" in interchange.collections:
        if len(interchange["VirtualSites"].key_map) > 0:
            warnings.warn(
                "Exporting virtual sites to GROMACS is EXPERIMENTAL and not yet thoroughly validated.",
            )

    if isinstance(file_path, str):
        path = Path(file_path)
    if isinstance(file_path, Path):
        path = file_path

    if interchange.box is None:
        if interchange["Electrostatics"].periodic_potential != _PME:
            raise UnsupportedExportError(
                f'Electrostatics method PME (`"{_PME}"`) is not valid for a non-periodic system. ',
            )

    # For performance, immediately convert everything into GROMACS units.  This
    # introduces an overhead but should pay off by allowing the blind use of
    # `Quantity.magnitdue` without the default unit-checking work.

    if "vdW" in interchange.collections:
        for potential in interchange["vdW"].potentials.values():
            potential.parameters["sigma"].ito(unit.nanometer)
            potential.parameters["epsilon"].ito(kj_mol)

    if "Bonds" in interchange.collections:
        for potential in interchange["Bonds"].potentials.values():
            potential.parameters["k"].ito(kj_mol / unit.nanometer**2)
            potential.parameters["length"].ito(unit.nanometer)

    if "Angles" in interchange.collections:
        for potential in interchange["Angles"].potentials.values():
            potential.parameters["k"].ito(kj_mol / unit.radian * 2)
            potential.parameters["angle"].ito(unit.degree)

    if "ProperTorsions" in interchange.collections:
        for potential in interchange["ProperTorsions"].potentials.values():
            potential.parameters["k"].ito(kj_mol)
            potential.parameters["phase"].ito(unit.degree)

    if "ImproperTorsions" in interchange.collections:
        for potential in interchange["ImproperTorsions"].potentials.values():
            potential.parameters["k"].ito(kj_mol)
            potential.parameters["phase"].ito(unit.degree)

    with open(path, "w") as top_file:
        top_file.write("; Generated by Interchange\n")
        _write_top_defaults(interchange, top_file)
        typemap = _build_typemap(interchange)
        virtual_site_map = _build_virtual_site_map(interchange)
        _write_atomtypes(interchange, top_file, typemap, virtual_site_map)
        # TODO: Write [ nonbond_params ] section

        try:
            lj_parameters = interchange["vdW"].get_system_parameters()
        except LookupError:
            lj_parameters = None

        unique_molecule_map: Dict[
            int,
            List,
        ] = interchange.topology.identical_molecule_groups

        for (
            unique_molecule_index,
            duplicate_molecule_data,
        ) in unique_molecule_map.items():
            unique_molecule = interchange.topology.molecule(unique_molecule_index)

            if unique_molecule.name == "":
                unique_molecule.name = "x" + str(unique_molecule_index)

            for row in duplicate_molecule_data:
                (duplciate_molecule_index, _) = row

                interchange.topology.molecule(
                    duplciate_molecule_index,
                ).name = unique_molecule.name

            _write_moleculetype(top_file, unique_molecule.name)
            _write_atoms(
                top_file,
                interchange,
                unique_molecule,
                typemap,
                virtual_site_map,
                _cached_parameters=lj_parameters,
            )
            _write_valence(top_file, interchange, unique_molecule)
            _write_virtual_sites(
                top_file,
                interchange,
                unique_molecule,
                virtual_site_map,
            )

        _write_system(top_file, interchange, unique_molecule_map)


def _write_top_defaults(interchange: "Interchange", top_file: IO):
    """Write [ defaults ] section."""
    top_file.write("[ defaults ]\n")
    top_file.write("; nbfunc\tcomb-rule\tgen-pairs\tfudgeLJ\tfudgeQQ\n")

    if "vdW" in interchange.collections:
        nbfunc = 1
        scale_lj = interchange["vdW"].scale_14
        gen_pairs = "no"
        handler_key = "vdW"
    elif "Buckingham-6" in interchange.collections:
        nbfunc = 2
        gen_pairs = "no"
        scale_lj = interchange["Buckingham-6"].scale_14
        handler_key = "Buckingham-6"
    else:
        raise UnsupportedExportError(
            "Could not find a handler for short-ranged vdW interactions that is compatible "
            "with GROMACS. Looked for collections named `vdW` and `Buckingham-6`.",
        )

    mixing_rule = interchange[handler_key].mixing_rule.lower()
    if mixing_rule == "lorentz-berthelot":
        comb_rule = 2
    elif mixing_rule == "geometric":
        comb_rule = 3
    elif mixing_rule == "buckingham" and handler_key == "Buckingham-6":
        # TODO: Not clear what the compatibility is here. `comb-rule` only applies to LJ terms.
        #  The documentation lists the combination rule for Buckingham potentials, but it does not
        #  seem like GROMACS will do this automatically, and needs to be implemented manully via
        #  [ nonbond_params ].
        # https://manual.gromacs.org/current/reference-manual/topologies/parameter-files.html#non-bonded-parameters
        # https://gromacs.bioexcel.eu/t/how-to-use-buckingham-function/1181/4
        comb_rule = 2
    else:
        raise UnsupportedExportError(
            f"Mixing rule `{mixing_rule} not compatible with GROMACS and/or not supported "
            "by current exporter. Supported values are `lorentz-berthelot` and `geometric`.",
        )

    top_file.write(
        f"{nbfunc:6d}\t"
        f"{comb_rule:6d}\t"
        f"{gen_pairs:6s}\t"
        f"{scale_lj:8.6f}\t"
        f"{interchange['Electrostatics'].scale_14:8.6f}\n\n",
    ),


def _build_typemap(interchange: "Interchange") -> Dict[int, str]:
    typemap = dict()
    elements: Dict[str, int] = dict()

    # TODO: Think about how this logic relates to atom name/type clashes
    for atom_index, atom in enumerate(interchange.topology.atoms):
        element_symbol = atom.symbol
        # TODO: Use this key to condense, see parmed.openmm._process_nobonded
        # parameters = _get_lj_parameters([*parameters.values()])
        # key = tuple([*parameters.values()])

        if element_symbol not in elements.keys():
            elements[element_symbol] = 1
        else:
            elements[element_symbol] += 1

        atom_type = f"{element_symbol}{elements[element_symbol]}"
        typemap[atom_index] = atom_type

    return typemap


def _build_virtual_site_map(interchange: "Interchange") -> Dict[VirtualSiteKey, int]:
    """
    Construct a mapping between the VirtualSiteKey objects found in a SMIRNOFFVirtualSiteHandler and particle indices.
    """
    virtual_site_topology_index_map: Dict[VirtualSiteKey, int] = dict()

    if "VirtualSites" not in interchange.collections:
        return virtual_site_topology_index_map

    n_atoms = interchange.topology.n_atoms

    for index, virtual_site_key in enumerate(
        interchange["VirtualSites"].key_map.keys(),
    ):
        assert isinstance(virtual_site_key, VirtualSiteKey)
        virtual_site_topology_index_map[virtual_site_key] = n_atoms + 1 + index

    return virtual_site_topology_index_map


def _write_atomtypes(
    interchange: "Interchange",
    top_file: IO,
    typemap: Dict,
    virtual_site_map: Dict,
):
    """Write [ atomtypes ] section."""
    if "vdW" in interchange.collections:
        if "Buckingham-6" in interchange.collections:
            raise UnsupportedExportError(
                "Cannot mix 12-6 and Buckingham potentials in GROMACS",
            )
        else:
            _write_atomtypes_lj(interchange, top_file, typemap, virtual_site_map)
    else:
        if "Buckingham-6" in interchange.collections:
            _write_atomtypes_buck(interchange, top_file, typemap)
        else:
            raise UnsupportedExportError("No vdW interactions found")

    top_file.write("\n")


def _write_atomtypes_lj(
    interchange: "Interchange",
    top_file: IO,
    typemap: Dict,
    virtual_site_map: Dict,
):
    """Write the [ atomtypes ] section when all atoms use the LJ potential."""
    top_file.write("[ atomtypes ]\n")
    top_file.write(";type, bondingtype, mass, charge, ptype, sigma, epsilon\n")

    lj_parameters: "ArrayLike" = interchange["vdW"].get_system_parameters()

    for atom_idx, atom_type in typemap.items():
        atom = interchange.topology.atom(atom_idx)
        mass = atom.mass.m
        atomic_number = atom.atomic_number
        sigma, epsilon = lj_parameters[atom_idx]  # type: ignore
        # TODO: Sometimes a "bondingtype" can sneak in to as the second column. This
        #       seems to be used commonly in how OPLS groups atom types for valence
        #       terms, and InterMol attempts to parse it as such, but the GROMACS
        #       documentation makes no mention of this behavior.
        top_file.write(
            "{:<11s} {:6d} {:.16g} {:.16f} {:5s} {:.16g} {:.16g}\n".format(
                atom_type,
                atomic_number,
                mass,
                0.0,  # charge, overriden later in [ atoms ]
                "A",  # ptype
                sigma,
                epsilon,
            ),
        )

    for virtual_site_key in virtual_site_map:
        # TODO: This can produce some silly-looking output because it does not attempt to condense virtual sites
        #       from different molecules with the same parameters. Should probably de-deuplicate across moleculces
        atom_type = "VS"
        atomic_number = 0
        mass = 0.0

        vdw_handler = interchange["vdW"]
        pot_key = vdw_handler.key_map[virtual_site_key]
        parameters = vdw_handler.potentials[pot_key].parameters
        sigma = parameters["sigma"].m
        epsilon = parameters["epsilon"].m

        top_file.write(
            "{:<11s} {:6d} {:.16g} {:.16g} {:5s} {:.16g} {:.16g}\n".format(
                atom_type,
                # "XX",  # atom "bonding type", i.e. bond class
                atomic_number,
                mass,
                0.0,  # charge, overriden later in [ atoms ]
                "A",  # ptype
                sigma,
                epsilon,
            ),
        )


def _write_atomtypes_buck(interchange: "Interchange", top_file: IO, typemap: Dict):
    """Write the [ atomtypes ] section when all atoms use the Buckingham-6 potential."""
    top_file.write("[ atomtypes ]\n")
    top_file.write(
        ";type, bondingtype, atomic_number, mass, charge, ptype, sigma, epsilon\n",
    )

    for atom_idx, atom_type in typemap.items():
        atom = interchange.topology.atom(atom_idx)
        parameters = _get_buck_parameters(interchange, atom_idx)
        a = parameters["A"].m_as(kj_mol)
        b = parameters["B"].m_as(1 / unit.nanometer)
        c = parameters["C"].m_as(kj_mol * unit.nanometer**6)

        top_file.write(
            "{:<11s} {:6d} {:.16g} {:.16g} {:5s} {:.16g} {:.16g} {:.16g}".format(
                atom_type,  # atom type
                # "XX",  # atom "bonding type", i.e. bond class
                atom.atomic_number,
                atom.mass.m,
                0.0,  # charge, overriden later in [ atoms ]
                "A",  # ptype
                a,
                b,
                c,
            ),
        )
        top_file.write("\n")


def _write_moleculetype(top_file: IO, molecule_name: str):
    """Write the [ moleculetype ] section."""
    top_file.write("[ moleculetype ]\n")
    top_file.write("; Name\tnrexcl\n")
    top_file.write(f"{molecule_name}\t3\n\n")


def _write_atoms(
    top_file: IO,
    interchange: "Interchange",
    molecule: "Molecule",
    typemap: Dict,
    virtual_site_map: Dict,
    _cached_parameters=None,
):
    """Write the [ atoms ] and [ pairs ] sections for a molecule."""
    top_file.write("[ atoms ]\n")
    top_file.write(";num, type, resnum, resname, atomname, cgnr, q, m\n")

    for atom in molecule.atoms:
        molecule_index = molecule.atom_index(atom)
        topology_index = interchange.topology.atom_index(atom)
        mass = atom.mass.m
        charge = (
            interchange["Electrostatics"]
            .charges_with_virtual_sites[TopologyKey(atom_indices=(topology_index,))]
            .m_as(
                unit.elementary_charge,
            )
        )
        atom_type = typemap[topology_index]
        atom_name = atom.name if atom.name else atom.symbol

        try:
            res_idx = atom.metadata["residue_number"]
            res_name = atom.metadata["residue_name"]
        except KeyError:
            res_idx = 0
            res_name = "UNK"

        # TODO: Figure out why charge increments were applied as an array
        # to the anchor atom involved in a BondChargeVirtualSite?
        if type(charge) == np.ndarray:
            charge = charge[0]

        top_file.write(
            "{:6d} {:18s} {:6d} {:8s} {:8s} {:6d} "
            "{:18.8f} {:18.8f}\n".format(
                molecule_index + 1,
                atom_type,
                int(res_idx),
                res_name,
                atom_name,
                molecule_index + 1,
                charge,
                mass,
            ),
        )

    index = molecule.n_atoms + 1

    for virtual_site_key in virtual_site_map:
        if not _this_key_is_in_molecule(
            virtual_site_key,
            interchange.topology,
            molecule,
        ):
            continue

        atom_idx = index
        atom_type = "VS"
        res_idx = 1
        res_name = "1"
        charge
        charge_handler = interchange["Electrostatics"]
        charge = charge_handler.charges_with_virtual_sites[virtual_site_key].m_as(
            unit.e,
        )
        mass = 0.0

        top_file.write(
            "{:6d} {:18s} {:6d} {:8s} {:8s} {:6d} "
            "{:18.8f} {:18.8f}\n".format(
                atom_idx,
                atom_type,
                res_idx,
                res_name,
                atom_type,
                atom_idx,
                charge,
                mass,
            ),
        )

        index += 1

    top_file.write("\n")

    top_file.write("[ pairs ]\n")
    top_file.write("; ai\taj\tfunct\n")

    try:
        mixing_rule = interchange["vdW"].mixing_rule.lower()
        scale_lj = interchange["vdW"].scale_14
    except LookupError:
        mixing_rule = interchange["Buckingham-6"].mixing_rule.lower()
        scale_lj = interchange["Buckingham-6"].scale_14

    # Use a set to de-duplicate
    pairs: Set[Tuple] = {*_get_14_pairs(molecule)}

    if "vdW" in interchange.collections:
        if _cached_parameters is None:
            lj_parameters: "ArrayLike" = interchange["vdW"].get_system_parameters()
        else:
            lj_parameters = _cached_parameters
    elif "Buckingham-6" in interchange.collections:
        warnings.warn("Not writing a [ pairs ] section with Buckingham interactions.")
        top_file.write("\n")
        return

    # TODO: Sort pairs by atom indices ascending
    for pair in pairs:
        molecule_indices = sorted(molecule.atom_index(atom) for atom in pair)
        topology_indices = sorted(
            interchange.topology.atom_index(atom) for atom in pair
        )
        sigma1, epsilon1 = lj_parameters[topology_indices[0]]  # type: ignore
        sigma2, epsilon2 = lj_parameters[topology_indices[1]]  # type: ignore
        epsilon_mix = (epsilon1 * epsilon2) ** 0.5
        if mixing_rule == "lorentz-berthelot":
            sigma_mix = (sigma1 + sigma2) * 0.5
        elif mixing_rule == "geometric":
            sigma_mix = (sigma1 * sigma2) ** 0.5
        top_file.write(
            "{:7d} {:7d} {:6d} {:.16g} {:.16g}\n".format(
                molecule_indices[0] + 1,
                molecule_indices[1] + 1,
                1,
                sigma_mix,
                epsilon_mix * scale_lj,
            ),
        )

    top_file.write("\n")


def _write_virtual_sites(
    top_file: IO,
    interchange: "Interchange",
    molecule: "Molecule",
    virtual_site_map: Dict,
):
    if "VirtualSites" not in interchange.collections:
        return

    virtual_site_handler = interchange["VirtualSites"]

    if not all(
        k.type in ["BondCharge", "MonovalentLonePair", "DivalentLonePair"]
        for k in virtual_site_handler.key_map
    ):
        raise NotImplementedError("Only BondCharge virtual sites are implemented")

    started_virtual_sites2 = False
    started_virtual_sites3 = False
    # TODO: Cleaner implementation than filter + sort? Maybe split it up into each type
    # and do them sequentially?

    key_map: Dict[VirtualSiteKey, PotentialKey] = virtual_site_handler.key_map

    # TODO: Consolidate this logic with identical code in coordinate writer

    # TODO: Lots of repeated code, like checking to see if a particular virtual site is in _this_
    #       molecule, etc., should consolidate

    used_keys = dict()

    virtual_site_index = molecule.n_atoms + 1

    for virtual_site_key in sorted(
        (k for k in key_map if type(k) == VirtualSiteKey),
        key=lambda x: x.type,
    ):
        if virtual_site_key.type == "BondCharge":
            if not started_virtual_sites2:
                top_file.write("\n[ virtual_sites2 ]\n; site  ai  aj  funct   a\n")
                started_virtual_sites2 = True

            orientation_atom_indices: Tuple[
                int,
                ...,
            ] = virtual_site_key.orientation_atom_indices

            if len(orientation_atom_indices) != 2:
                raise NotImplementedError

            offset = interchange.topology.atom_index(molecule.atom(0)) - 1

            # virtual_site_index = virtual_site_map[virtual_site_key]
            atom1 = orientation_atom_indices[0]
            atom2 = orientation_atom_indices[1]

            func = 2

            distance = (
                virtual_site_handler.potentials[key_map[virtual_site_key]]
                .parameters["distance"]
                .m_as(unit.nanometer)
            )

            a = distance

            top_file.write(
                f"{virtual_site_index}\t\t{atom1-offset}\t{atom2-offset}\t"
                f"{func}\t{a}\n",
            )

            used_keys.update({virtual_site_index: virtual_site_key})

        if virtual_site_key.type == "MonovalentLonePair":
            if not started_virtual_sites3:
                top_file.write(
                    "\n[ virtual_sites3 ]\n; site  ai  aj  ak funct   a   b\n",
                )
                started_virtual_sites3 = True

            reference_atoms = tuple(sorted(virtual_site_key.orientation_atom_indices))
            if len(reference_atoms) != 3:
                raise NotImplementedError

            offset = interchange.topology.atom_index(molecule.atom(0)) - 1

            atom1 = reference_atoms[0]
            atom2 = reference_atoms[1]
            atom3 = reference_atoms[2]

            if not _this_key_is_in_molecule(
                virtual_site_key,
                interchange.topology,
                molecule,
            ):
                continue

            func = 3  # "3fad"

            out_of_plane_angle = (
                virtual_site_handler.potentials[key_map[virtual_site_key]]
                .parameters["outOfPlaneAngle"]
                .m_as(unit.radian)
            )

            if out_of_plane_angle != 0.0:
                raise NotImplementedError(
                    "Unclear how to do MonovalentLonePair virtual sites with GROMACS",
                )

            distance = (
                virtual_site_handler.potentials[key_map[virtual_site_key]]
                .parameters["distance"]
                .m_as(unit.nanometer)
            )

            in_plane_angle = (
                virtual_site_handler.potentials[key_map[virtual_site_key]]
                .parameters["inPlaneAngle"]
                .m_as(unit.degree)
            )

            in_plane_angle_transformed = 180 - in_plane_angle

            top_file.write(
                f"{virtual_site_index}\t\t{atom1 -offset}\t{atom2 -offset}\t{atom3 -offset}\t"
                f"{func}\t{in_plane_angle_transformed}\t{distance}\n",
            )

            used_keys.update({virtual_site_index: virtual_site_key})

        if virtual_site_key.type == "DivalentLonePair":
            if not started_virtual_sites3:
                top_file.write(
                    "\n[ virtual_sites3 ]\n; site  ai  aj  ak funct   a   b\n",
                )
                started_virtual_sites3 = True

            # TODO: Cannot sort here. Atom ordering implies "chirality" of virtual sites,
            #  i.e. which side of a 5-site water each lone pair particle should go.
            reference_atoms = tuple(sorted(virtual_site_key.orientation_atom_indices))

            if len(reference_atoms) != 3:
                raise NotImplementedError

            offset = interchange.topology.atom_index(molecule.atom(0)) - 1

            # GROMACS indexes molecules at 1, so the offset is "one less" than 0-indexed OpenFF indices
            offset = interchange.topology.atom_index(molecule.atom(0)) - 1

            atom1 = reference_atoms[0]
            atom2 = reference_atoms[1]
            atom3 = reference_atoms[2]

            if _this_key_is_in_molecule(
                virtual_site_key,
                interchange.topology,
                molecule,
            ):
                pass
            else:
                continue

            func = 1

            bond1_key = BondKey(atom_indices=(atom1, atom2))
            bond1_length = (
                interchange["Bonds"]
                .potentials[interchange["Bonds"].key_map[bond1_key]]
                .parameters["length"]
                .m_as(unit.nanometer)
            )

            bond2_key = BondKey(atom_indices=(atom1, atom3))
            bond2_length = (
                interchange["Bonds"]
                .potentials[interchange["Bonds"].key_map[bond2_key]]
                .parameters["length"]
                .m_as(unit.nanometer)
            )

            if bond1_length != bond2_length:
                raise NotImplementedError

            angle_key = TopologyKey(atom_indices=(atom2, atom1, atom3))
            angle = (
                interchange["Angles"]
                .potentials[interchange["Angles"].key_map[angle_key]]
                .parameters["angle"]
                .m_as(unit.radian)
            )

            distance = (
                virtual_site_handler.potentials[key_map[virtual_site_key]]
                .parameters["distance"]
                .m_as(unit.nanometer)
            )

            out_of_plane_angle = (
                virtual_site_handler.potentials[key_map[virtual_site_key]]
                .parameters["outOfPlaneAngle"]
                .m_as(unit.radian)
            )

            if out_of_plane_angle == 0:
                func = 1

                a = -1.0 * distance / (math.cos(angle / 2.0) * bond1_length) / 2.0

                top_file.write(
                    f"{virtual_site_index}\t\t{atom1 -offset }\t{atom2 -offset}\t{atom3-offset}"
                    f"\t{func}\t{a}\t{a}\n",
                )

                used_keys.update({virtual_site_index: virtual_site_key})

            else:
                func = 4
                a = (-1 * distance * math.cos(out_of_plane_angle)) / (
                    2 * bond1_length * math.cos(angle / 2)
                )
                c = (-1 * distance * math.sin(out_of_plane_angle)) / (
                    bond1_length**2 * math.sin(angle)
                )

                top_file.write(
                    f"{virtual_site_index}\t\t{atom1-offset}\t{atom2-offset}\t{atom3-offset}"
                    f"\t{func}\t{a}\t{a}\t{c}\n",
                )

                used_keys.update({virtual_site_index: virtual_site_key})

    if len(used_keys) > 0:
        top_file.write("\n[ exclusions ]\n")

    for virtual_site_index, virtual_site_key in used_keys.items():
        orientation_atom_indices = virtual_site_key.orientation_atom_indices

        top_file.write(f"{virtual_site_index}\t")
        top_file.write("\t".join([str(i - offset) for i in orientation_atom_indices]))
        top_file.write("\n")

    top_file.write("\n")


def _write_valence(
    top_file: IO,
    interchange: "Interchange",
    molecule: "Molecule",
):
    """Write the [ bonds ], [ angles ], and [ dihedrals ] sections."""
    _write_bonds(top_file, interchange, molecule)
    _write_angles(top_file, interchange, molecule)
    _write_dihedrals(top_file, interchange, molecule)


def _write_bonds(top_file: IO, interchange: "Interchange", molecule: "Molecule"):
    if "Bonds" not in interchange.collections.keys():
        return

    top_file.write("[ bonds ]\n")
    top_file.write("; ai\taj\tfunc\tr\tk\n")

    bond_handler = interchange["Bonds"]

    for bond in molecule.bonds:
        topology_indices = tuple(
            sorted(interchange.topology.atom_index(a) for a in bond.atoms),
        )
        molecule_indices = tuple(sorted(molecule.atom_index(a) for a in bond.atoms))
        topology_indices = tuple(
            sorted(interchange.topology.atom_index(atom) for atom in bond.atoms),
        )

        found_match = False
        for top_key in bond_handler.key_map:
            top_key: TopologyKey  # type: ignore[no-redef]
            if top_key.atom_indices == topology_indices:
                pot_key = bond_handler.key_map[top_key]
                found_match = True
                break
            elif top_key.atom_indices == topology_indices[::-1]:
                pot_key = bond_handler.key_map[top_key]
                found_match = True
                break
            else:
                found_match = False

        if not found_match:
            print(
                f"Failed to find parameters for bond with topology indices {topology_indices}",
            )
            continue

        params = bond_handler.potentials[pot_key].parameters

        k = params["k"].m
        length = params["length"].m

        top_file.write(
            "{:7d} {:7d} {:4s} {:.16g} {:.16g}\n".format(
                molecule_indices[0] + 1,  # atom i
                molecule_indices[1] + 1,  # atom j
                str(1),  # bond type (functional form)
                length,
                k,
            ),
        )

        del pot_key

    top_file.write("\n\n")


def _write_angles(top_file: IO, interchange: "Interchange", molecule: "Molecule"):
    if "Angles" not in interchange.collections.keys():
        return

    top_file.write("[ angles ]\n")
    top_file.write("; ai\taj\tak\tfunc\tr\tk\n")

    angle_handler = interchange["Angles"]

    for angle in molecule.angles:
        # TODO: Toolkit makes little guarantees about atom ordering in angles
        #       (only that the index of the first is less than the last)
        #       Easy breakage point
        topology_indices = tuple(interchange.topology.atom_index(a) for a in angle)
        molecule_indices = tuple(molecule.atom_index(a) for a in angle)

        for top_key in angle_handler.key_map:
            if top_key.atom_indices == topology_indices:
                pot_key = angle_handler.key_map[top_key]

        params = angle_handler.potentials[pot_key].parameters
        k = params["k"].m
        theta = params["angle"].m

        top_file.write(
            "{:7d} {:7d} {:7d} {:4s} {:.16g} {:.16g}\n".format(
                molecule_indices[0] + 1,  # atom i
                molecule_indices[1] + 1,  # atom j
                molecule_indices[2] + 1,  # atom k
                str(1),  # angle type (functional form)
                theta,
                k,
            ),
        )

    top_file.write("\n")


def _write_dihedrals(top_file: IO, interchange: "Interchange", molecule: "Molecule"):
    if "ProperTorsions" not in interchange.collections:
        if "RBTorsions" not in interchange.collections:
            if "ImproperTorsions" not in interchange.collections:
                return

    top_file.write("[ dihedrals ]\n")
    top_file.write(";    i      j      k      l   func\n")

    # FIXME: RB Impropers are probably missed here
    rb_torsion_handler: Optional["Collection"] = interchange.collections.get(
        "RBTorsions",
        None,
    )
    proper_torsion_handler: Optional["Collection"] = interchange.collections.get(
        "ProperTorsions",
        None,
    )
    improper_torsion_handler: Optional["Collection"] = interchange.collections.get(
        "ImproperTorsions",
        None,
    )

    # TODO: Ensure number of torsions written matches what is expected
    for proper in molecule.propers:
        topology_indices = tuple(interchange.topology.atom_index(a) for a in proper)
        molecule_indices = tuple(molecule.atom_index(a) for a in proper)

        if proper_torsion_handler:
            for top_key in proper_torsion_handler.key_map:
                if top_key.atom_indices[0] != topology_indices[0]:
                    continue
                if top_key.atom_indices[1] != topology_indices[1]:
                    continue
                if top_key.atom_indices[2] != topology_indices[2]:
                    continue
                if top_key.atom_indices[3] != topology_indices[3]:
                    continue
                if top_key.atom_indices == topology_indices:
                    pot_key = proper_torsion_handler.key_map[top_key]
                    params = proper_torsion_handler.potentials[pot_key].parameters

                    k = params["k"].m
                    periodicity = int(params["periodicity"])
                    phase = params["phase"].m
                    idivf = int(params["idivf"]) if "idivf" in params else 1
                    top_file.write(
                        f"{molecule_indices[0] + 1:7d}\t"
                        f"{molecule_indices[1] + 1:7d}\t"
                        f"{molecule_indices[2] + 1:7d}\t"
                        f"{molecule_indices[3] + 1:7d}\t"
                        f"{1:6d}\t"
                        f"{phase:.16g}\t"
                        f"{k / idivf:.16g}\t"
                        f"{periodicity:7d}\n",
                    )
        # This should be `if` if a single quartet can be subject to both proper and RB torsions
        if rb_torsion_handler:
            for top_key in rb_torsion_handler.key_map:
                if top_key.atom_indices[0] != topology_indices[0]:
                    continue
                if top_key.atom_indices[1] != topology_indices[1]:
                    continue
                if top_key.atom_indices[2] != topology_indices[2]:
                    continue
                if top_key.atom_indices[3] != topology_indices[3]:
                    continue
                if top_key.atom_indices == topology_indices:
                    pot_key = rb_torsion_handler.key_map[top_key]
                    params = rb_torsion_handler.potentials[pot_key].parameters

                    c0 = params["C0"].m_as(kj_mol)
                    c1 = params["C1"].m_as(kj_mol)
                    c2 = params["C2"].m_as(kj_mol)
                    c3 = params["C3"].m_as(kj_mol)
                    c4 = params["C4"].m_as(kj_mol)
                    c5 = params["C5"].m_as(kj_mol)

                    top_file.write(
                        "{:7d} {:7d} {:7d} {:7d} {:6d} "
                        "{:.16g} {:.16g} {:.16g} {:.16g} {:.16g} {:.16g} \n".format(
                            molecule_indices[0] + 1,
                            molecule_indices[1] + 1,
                            molecule_indices[2] + 1,
                            molecule_indices[3] + 1,
                            3,
                            c0,
                            c1,
                            c2,
                            c3,
                            c4,
                            c5,
                        ),
                    )

    # TODO: Ensure number of torsions written matches what is expected
    if improper_torsion_handler:
        # Molecule/Topology.impropers lists the central atom **second** ...
        for improper in molecule.smirnoff_impropers:
            topology_indices = tuple(
                interchange.topology.atom_index(a) for a in improper
            )
            # ... so the tuple must be modified to list the central atom **first**,
            # which is how the improper handler's slot map is built up
            indices_to_match = (
                topology_indices[1],
                topology_indices[0],
                topology_indices[2],
                topology_indices[3],
            )

            molecule_indices = tuple(molecule.atom_index(a) for a in improper)

            # Now, indices_to_match has the central atom listed **first**,
            # but it's still listed second in molecule_indices

            for top_key in improper_torsion_handler.key_map:
                if top_key.atom_indices[0] != indices_to_match[0]:
                    continue
                if top_key.atom_indices[1] != indices_to_match[1]:
                    continue
                if top_key.atom_indices[2] != indices_to_match[2]:
                    continue
                if top_key.atom_indices[3] != indices_to_match[3]:
                    continue
                if indices_to_match == top_key.atom_indices:
                    key = improper_torsion_handler.key_map[top_key]
                    params = improper_torsion_handler.potentials[key].parameters

                    k = params["k"].m
                    periodicity = int(params["periodicity"])
                    phase = params["phase"].m
                    idivf = int(params["idivf"])
                    top_file.write(
                        "{:7d} {:7d} {:7d} {:7d} {:6d} {:.16g} {:.16g} {:.16g}\n".format(
                            # central atom is listed first in GROMACS
                            molecule_indices[1] + 1,
                            molecule_indices[0] + 1,
                            molecule_indices[2] + 1,
                            molecule_indices[3] + 1,
                            4,
                            phase,
                            k / idivf,
                            periodicity,
                        ),
                    )

    top_file.write("\n")


def _write_system(
    top_file: IO,
    interchange: "Interchange",
    uniqe_molecule_map: Dict[int, List],
):
    """Write the [ system ] section."""
    top_file.write("[ system ]\n")
    top_file.write("; name \n")
    top_file.write("System name\n\n")

    top_file.write("[ molecules ]\n")
    top_file.write("; Compound\tnmols\n")

    for molecule in interchange.topology.molecules:
        top_file.write(f"{molecule.name}\t1\n")

    top_file.write("\n")


def _this_key_is_in_molecule(
    virtual_site_key: VirtualSiteKey,
    topology: Topology,
    molecule: Molecule,
    shortcut=True,
) -> bool:
    """
    Assert that all orientation atoms in this key are in this molecule.

    The `shortcut` code path assumes that if the parent atom of a virtual site is in a molecule, all of
    the orientation atoms are as well.
    """
    if shortcut:
        parent_atom = topology.atom(virtual_site_key.orientation_atom_indices[0])

        return parent_atom.molecule is molecule

    else:
        topology_atom_indices = [topology.atom_index(atom) for atom in molecule.atoms]

        return all(
            orientation_atom_index in topology_atom_indices
            for orientation_atom_index in virtual_site_key.orientation_atom_indices
        )


def _get_buck_parameters(interchange: "Interchange", atom_idx: int) -> Dict:
    buck_hander = interchange["Buckingham-6"]
    atom_key = TopologyKey(atom_indices=(atom_idx,))
    identifier = buck_hander.key_map[atom_key]
    potential = buck_hander.potentials[identifier]
    parameters = potential.parameters

    return parameters


def _get_residue_info_from_atom(atom) -> Tuple[int, str]:
    try:
        # TODO: Unclear if OpenFF will make residues start at 1 or 0
        residue_idx = int(atom.metadata["residue_number"]) % 100000
        # TODO: After topology refactor, ensure this matches residue names
        # in the topology file (unsure if this is necessary?)
        residue_name = atom.metadata["residue_name"][:5]
    except KeyError:
        residue_idx = 0
        residue_name = "UNK"

    return residue_idx, residue_name
